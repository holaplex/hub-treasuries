//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.0

use async_graphql::*;
use sea_orm::{entity::prelude::*, FromQueryResult, SelectTwo};
use serde::{Deserialize, Serialize};

use super::{project_treasuries, wallets};
use crate::AppContext;

/// A collection of wallets assigned to different entities in the Holaplex ecosystem.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize, SimpleObject)]
#[sea_orm(table_name = "treasuries")]
#[graphql(complex, concrete(name = "Treasury", params()))]
pub struct Model {
    /// The unique identifier for the treasury.
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    /// The associated Fireblocks vault ID.
    /// ## Reference
    /// [Vault Objects](https://docs.fireblocks.com/api/#vault-objects)
    #[sea_orm(unique)]
    pub vault_id: String,
    /// The creation DateTimeWithTimeZone of the vault.
    pub created_at: DateTimeWithTimeZone,
}

#[ComplexObject]

impl Model {
    /// The treasury's associated wallets.
    async fn wallets(&self, ctx: &Context<'_>) -> Result<Option<Vec<wallets::Model>>> {
        let AppContext {
            treasury_wallets_loader,
            ..
        } = ctx.data::<AppContext>()?;

        treasury_wallets_loader.load_one(self.id).await
    }

    /// Lookup a wallet based on its `asset_type`.
    async fn wallet(
        &self,
        ctx: &Context<'_>,
        asset_type: wallets::AssetType,
    ) -> Result<Option<wallets::Model>> {
        let AppContext {
            treasury_wallets_loader,
            ..
        } = ctx.data::<AppContext>()?;

        let wallets = treasury_wallets_loader
            .load_one(self.id)
            .await?
            .unwrap_or_default();

        Ok(wallets
            .into_iter()
            .find(|wallet| wallet.asset_id == asset_type))
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "super::customer_treasuries::Entity")]
    CustomerTreasuries,
    #[sea_orm(has_one = "super::project_treasuries::Entity")]
    ProjectTreasuries,
    #[sea_orm(has_many = "super::wallets::Entity")]
    Wallets,
}

impl Related<super::customer_treasuries::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::CustomerTreasuries.def()
    }
}

impl Related<super::project_treasuries::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::ProjectTreasuries.def()
    }
}

impl Related<super::wallets::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Wallets.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(FromQueryResult)]
pub struct TreasuryAndProjectIds {
    pub id: Uuid,
    pub vault_id: String,
    pub customer_project_id: Option<Uuid>,
    pub customer_id: Option<Uuid>,
    pub project_project_id: Option<Uuid>,
}

impl Entity {
    pub async fn find_by_project_id(id: Uuid) -> SelectTwo<project_treasuries::Entity, Entity> {
        project_treasuries::Entity::find()
            .find_also_related(Entity)
            .filter(project_treasuries::Column::ProjectId.eq(id))
    }
}
